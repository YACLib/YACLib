#pragma once

#include <cstddef>

#if defined(__has_feature)
#  if __has_feature(address_sanitizer) || ${YACLIB_ASAN}
#    define YACLIB_ASAN
#  endif
#  if __has_feature(thread_sanitizer) || ${YACLIB_TSAN}
#    define YACLIB_TSAN
#  endif
#  if __has_feature(memory_sanitizer) || ${YACLIB_MEMSAN}
#    define YACLIB_MEMSAN
#  endif
#  if __has_feature(undefined_behavior_sanitizer) || ${YACLIB_UBSAN}
#    define YACLIB_UBSAN
#  endif
#else
#  if defined(__SANITIZE_ADDRESS__) || ${YACLIB_ASAN}
#    define YACLIB_ASAN
#  endif
#  if defined(__SANITIZE_THREAD__) || ${YACLIB_TSAN}
#    define YACLIB_TSAN
#  endif
#  if defined(__SANITIZE_UNDEFINED__) || ${YACLIB_UBSAN}
#    define YACLIB_UBSAN
#  endif
#endif

#define YACLIB_FAULT ${YACLIB_FAULT}
// TODO(myannyax) YACLIB_SLOWDOWN with fault

// Maybe we should increase some of this
#ifndef YACLIB_SLOWDOWN
#  if defined(YACLIB_ASAN)
#    define YACLIB_SLOWDOWN 2
#  elif defined(YACLIB_TSAN)
#    define YACLIB_SLOWDOWN 2
#  elif defined(YACLIB_MEMSAN)
#    define YACLIB_SLOWDOWN 1
#  else
#    define YACLIB_SLOWDOWN 1
#  endif
#endif

#ifndef YACLIB_MEMORY_OVERHEAD
#  if defined(YACLIB_ASAN)
#    define YACLIB_MEMORY_OVERHEAD 3
#  elif defined(YACLIB_TSAN)
#    define YACLIB_MEMORY_OVERHEAD 3
#  elif defined(YACLIB_MEMSAN)
#    define YACLIB_MEMORY_OVERHEAD 1
#  else
#    define YACLIB_MEMORY_OVERHEAD 1
#  endif
#endif

#if ${YACLIB_ATOMIC_EVENT}
#  define YACLIB_ATOMIC_EVENT
#endif

#define YACLIB_CORO ${YACLIB_CORO}

// TODO(MBkkt) Maybe make all single line not virtual functions are YACLIB_INLINE?
// Now I use YACLIB_INLINE for
// * AtomicCounter::SubEqual
//     Because I want to compiler generate code without jmp and with correct barriers
// * Wait like functions, that just template single line wrappers for general functions
//     Because I want to compiler don't store the instantiation of these functions,
//     in other words, so that this template code has a minimal impact, primarily on compile time
// Now I interested in
// * await_resume/suspend/ready
//     TODO(MBkkt, mkornaukhov03) Research performance impact of visibility/inlining these functions
// * all single-line/single-if header-only yaclib functions

#if !defined(YACLIB_INLINE)  // Can be used only in special case
#  if ${YACLIB_COVERAGE}
#    define YACLIB_INLINE inline
#  elif defined(_MSC_VER)
#    if (_MSC_VER >= 1900 && !defined(_DEBUG))  // old and debug MSVC have problems with "__forceinline"
#      define YACLIB_INLINE __forceinline
#    else
#      define YACLIB_INLINE inline
#    endif
#  elif defined(__GNUC__) && (defined(__clang__) || __GNUC__ > 5)  // old GCC have problems with "__always_inline__"
#    define YACLIB_INLINE inline __attribute__((__always_inline__))
#  else
#    define YACLIB_INLINE inline
#  endif
#endif

#if !defined(YACLIB_NO_UNIQUE_ADDRESS) && defined(__has_cpp_attribute)
#  if __has_cpp_attribute(no_unique_address)
#    define YACLIB_NO_UNIQUE_ADDRESS [[no_unique_address]]
#  endif
#endif

#if !defined(YACLIB_NO_UNIQUE_ADDRESS) && defined(__has_attribute)
#  if __has_attribute(no_unique_address)
#    define YACLIB_NO_UNIQUE_ADDRESS [[no_unique_address]]
#  endif
#endif

#ifndef YACLIB_NO_UNIQUE_ADDRESS
#  define YACLIB_NO_UNIQUE_ADDRESS
#endif

namespace yaclib {

inline constexpr std::size_t kCacheLineSize = 64;  // TODO(MBkkt) Make better

}  // namespace yaclib
