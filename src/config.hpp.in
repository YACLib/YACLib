#pragma once

#include <cstddef>

#if defined(__has_feature)
#  if __has_feature(address_sanitizer) || ${YACLIB_ASAN}
#    define YACLIB_ASAN
#  endif
#  if __has_feature(thread_sanitizer) || ${YACLIB_TSAN}
#    define YACLIB_TSAN
#  endif
#  if __has_feature(memory_sanitizer) || ${YACLIB_MEMSAN}
#    define YACLIB_MEMSAN
#  endif
#  if __has_feature(undefined_behavior_sanitizer) || ${YACLIB_UBSAN}
#    define YACLIB_UBSAN
#  endif
#else
#  if defined(__SANITIZE_ADDRESS__) || ${YACLIB_ASAN}
#    define YACLIB_ASAN
#  endif
#  if defined(__SANITIZE_THREAD__) || ${YACLIB_TSAN}
#    define YACLIB_TSAN
#  endif
#  if defined(__SANITIZE_UNDEFINED__) || ${YACLIB_UBSAN}
#    define YACLIB_UBSAN
#  endif
#endif

#define YACLIB_FAULT ${YACLIB_FAULT}
// TODO(myannyax) YACLIB_SLOWDOWN with fault

// Maybe we should increase some of this
#ifndef YACLIB_SLOWDOWN
#  if defined(YACLIB_ASAN)
#    define YACLIB_SLOWDOWN 2
#  elif defined(YACLIB_TSAN)
#    define YACLIB_SLOWDOWN 2
#  elif defined(YACLIB_MEMSAN)
#    define YACLIB_SLOWDOWN 1
#  else
#    define YACLIB_SLOWDOWN 1
#  endif
#endif

#ifndef YACLIB_MEMORY_OVERHEAD
#  if defined(YACLIB_ASAN)
#    define YACLIB_MEMORY_OVERHEAD 3
#  elif defined(YACLIB_TSAN)
#    define YACLIB_MEMORY_OVERHEAD 3
#  elif defined(YACLIB_MEMSAN)
#    define YACLIB_MEMORY_OVERHEAD 1
#  else
#    define YACLIB_MEMORY_OVERHEAD 1
#  endif
#endif

#if ${YACLIB_ATOMIC_EVENT}
#  define YACLIB_ATOMIC_EVENT
#endif

// TODO(MBkkt) Maybe make all single line not virtual functions are YACLIB_INLINE?
// Now I use YACLIB_INLINE for
// * AtomicCounter::SubEqual
//     Because I want to compiler generate code without jmp and with correct barriers
// * Wait like functions, that just template single line wrappers for general functions
//     Because I want to compiler don't store the instantiation of these functions,
//     in other words, so that this template code has a minimal impact, primarily on compile time
// Now I interested in
// * await_resume/suspend/ready
//     TODO(MBkkt, mkornaukhov03) Research performance impact of visibility/inlining these functions
// * all single-line/single-if header-only yaclib functions

#if !defined(YACLIB_INLINE)  // Can be used only in special case
#  if ${YACLIB_COVERAGE}
#    define YACLIB_INLINE inline
#  elif defined(_MSC_VER)
#    if (_MSC_VER >= 1900 && !defined(_DEBUG))  // old and debug MSVC have problems with "__forceinline"
#      define YACLIB_INLINE __forceinline
#    else
#      define YACLIB_INLINE inline
#    endif
#  elif defined(__GNUC__) && (defined(__clang__) || __GNUC__ > 5)  // old GCC have problems with "__always_inline__"
#    define YACLIB_INLINE inline __attribute__((__always_inline__))
#  else
#    define YACLIB_INLINE inline
#  endif
#endif

// TODO(mkornaukhov03) figure out more convinient way how to check the possibility of Symmetric Transfer
// Now it has a problem: doesn't use Symmetric Transfer even if possible
#if ${YACLIB_CORO_NEED}
#  if defined(__clang__)
#    define YACLIB_SYMMETRIC_TRANSFER 1
#    if defined __has_include
#      if __has_include(<coroutine>)
#        define YACLIB_CORO 2
#      else
#        define YACLIB_CORO 1
#      endif
# 	 endif
#    if defined(__apple_build_version) && defined(YACLIB_TSAN)
#      if __apple_build_version < 13100000
#        define YACLIB_SYMMETRIC_TRANSFER 0 // because of TSAN problems
#      endif
#    endif
#  elif defined(__GNUG__)
#    define YACLIB_SYMMETRIC_TRANSFER 1
#    define YACLIB_CORO 2
#  elif defined(_MSC_VER)
#    if _MSC_VER > 1928
#      define YACLIB_CORO 2
#      define YACLIB_TRANSFER 1
#    else
#      define YACLIB_CORO 1
#      define YACLIB_TRANSFER 0
#    endif
#  else
#    define YACLIB_SYMMETRIC_TRANSFER 1
#    define YACLIB_CORO 2
#  endif
#endif
namespace yaclib {

inline constexpr std::size_t kCacheLineSize = 64;  // TODO(MBkkt) Make better

}  // namespace yaclib
