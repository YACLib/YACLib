<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="Doxygen Awesome" />
<meta property="og:image" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta property="og:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta name="twitter:title" content="Doxygen Awesome" />
<meta name="twitter:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<!-- END twitter metadata -->
<title>YACLib: YACLib</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/YACLib/YACLib" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YACLib
   </div>
   <div id="projectbrief">C++ library for concurrent tasks execution</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">YACLib </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <a href="https://github.com/YACLib/YACLib">Yet Another Concurrency Library</a></p>
<p><a href="https://raw.githubusercontent.com/YACLib/YACLib/main/LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="GitHub license" style="pointer-events: none;" class="inline"/></a> <a href="https://app.fossa.com/projects/git%2Bgithub.com%2FYACLib%2FYACLib"><img src="https://app.fossa.com/api/projects/git%2Bgithub.com%2FYACLib%2FYACLib.svg?type=shield" alt="FOSSA status" style="pointer-events: none;" class="inline"/></a></p>
<p><a href="https://github.com/YACLib/YACLib/actions/workflows/linux.yml"><img src="https://github.com/YACLib/YACLib/actions/workflows/linux.yml/badge.svg?branch=main" alt="Linux" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/YACLib/YACLib/actions/workflows/macos.yml"><img src="https://github.com/YACLib/YACLib/actions/workflows/macos.yml/badge.svg?branch=main" alt="macOS" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/YACLib/YACLib/actions/workflows/windows.yml"><img src="https://github.com/YACLib/YACLib/actions/workflows/windows.yml/badge.svg?branch=main" alt="Windows" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/YACLib/YACLib/actions/workflows/sanitizer.yml"><img src="https://github.com/YACLib/YACLib/actions/workflows/sanitizer.yml/badge.svg?branch=main" alt="Sanitizers" style="pointer-events: none;" class="inline"/></a></p>
<p><a href="https://coveralls.io/github/YACLib/YACLib?branch=main"><img src="https://coveralls.io/repos/github/YACLib/YACLib/badge.svg?branch=main" alt="Test coverage: coveralls" style="pointer-events: none;" class="inline"/></a> <a href="https://codecov.io/gh/YACLib/YACLib"><img src="https://codecov.io/gh/YACLib/YACLib/branch/main/graph/badge.svg" alt="Test coverage: codecov" style="pointer-events: none;" class="inline"/></a></p>
<p><a href="https://discord.gg/xy2fDKj8VZ"><img src="https://discordapp.com/api/guilds/898966884471423026/widget.png" alt="Discord" class="inline"/></a></p>
<h1>Table of Contents</h1>
<ul>
<li>About YACLib</li>
<li>Getting started</li>
<li>Examples<ul>
<li>Asynchronous pipeline</li>
<li>C++20 coroutine</li>
<li>Lazy pipeline</li>
<li>Thread pool</li>
<li>Strand, Serial executor</li>
<li>Mutex</li>
<li>Rescheduling</li>
<li>WhenAll</li>
<li>WhenAny</li>
<li>Future unwrapping</li>
<li>Timed wait</li>
<li>WaitGroup</li>
<li>Exception recovering</li>
<li>Error recovering</li>
<li>Using Result for smart recovering</li>
</ul>
</li>
<li>Requirements</li>
<li>Releases</li>
<li>Contributing</li>
<li>Thanks</li>
<li>Contacts</li>
<li>License</li>
</ul>
<h1>About YACLib</h1>
<p><b>YACLib</b> is a lightweight C++ library for concurrent and parallel task execution, that is striving to satisfy the following properties:</p>
<ul>
<li>Zero cost abstractions</li>
<li>Easy to use</li>
<li>Easy to build</li>
<li>Good test coverage</li>
</ul>
<p>For more details check our <a class="el" href="md_doc_2design.html">design document</a> and <a href="https://yaclib.github.io/YACLib">documentation</a>.</p>
<h1>Getting started</h1>
<p>For quick start just paste this code in your <code>CMakeLists.txt</code> file.</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line">FetchContent_Declare(yaclib</div>
<div class="line">  GIT_REPOSITORY https://github.com/YACLib/YACLib.git</div>
<div class="line">  GIT_TAG main</div>
<div class="line">)</div>
<div class="line">FetchContent_MakeAvailable(yaclib)</div>
<div class="line">link_libraries(yaclib)</div>
</div><!-- fragment --><p>For more details check <a class="el" href="md_doc_2install.html">install guide</a>.</p>
<p>For more details about '<a class="el" href="namespaceyaclib__std.html">yaclib_std</a>' or fault injection, check <a class="el" href="md_doc_2yaclib__std.html">doc</a>.</p>
<h1>Examples</h1>
<p>Here are short examples of using some features from YACLib, for details check <a href="https://yaclib.github.io/YACLib/examples.html">documentation</a>.</p>
<h3>Asynchronous pipeline</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> cpu_tp{<span class="comment">/*threads=*/</span>4};</div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> io_tp{<span class="comment">/*threads=*/</span>1};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(cpu_tp, [] {  <span class="comment">// on cpu_tp</span></div>
<div class="line">  <span class="keywordflow">return</span> 42;</div>
<div class="line">}).ThenInline([](<span class="keywordtype">int</span> r) {  <span class="comment">// called directly after &#39;return 42&#39;, without Submit to cpu_tp</span></div>
<div class="line">  <span class="keywordflow">return</span> r + 1;</div>
<div class="line">}).Then([](<span class="keywordtype">int</span> r) {  <span class="comment">// on cpu_tp</span></div>
<div class="line">  <span class="keywordflow">return</span> std::to_string(r);</div>
<div class="line">}).<a class="code hl_enumvalue" href="namespaceyaclib_1_1detail.html#a8d958ef9a3a9b6191c21e88df65cec2baf200763a0dca7d4843032c057804f9e9">Detach</a>(io_tp, [](std::string&amp;&amp; r) {  <span class="comment">// on io_tp</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Pipeline result: &lt;&quot;</span>  &lt;&lt; r &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl; <span class="comment">// 43</span></div>
<div class="line">});</div>
<div class="ttc" id="aclassyaclib_1_1FairThreadPool_html"><div class="ttname"><a href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a></div><div class="ttdoc">TODO(kononovk) Doxygen docs.</div><div class="ttdef"><b>Definition</b> <a href="fair__thread__pool_8hpp_source.html#l00018">fair_thread_pool.hpp:18</a></div></div>
<div class="ttc" id="anamespaceyaclib_1_1detail_html_a8d958ef9a3a9b6191c21e88df65cec2baf200763a0dca7d4843032c057804f9e9"><div class="ttname"><a href="namespaceyaclib_1_1detail.html#a8d958ef9a3a9b6191c21e88df65cec2baf200763a0dca7d4843032c057804f9e9">yaclib::detail::CoreType::Detach</a></div><div class="ttdeci">@ Detach</div></div>
<div class="ttc" id="anamespaceyaclib_html_a7a1e816f25355b1f23b01433879ed0ec"><div class="ttname"><a href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a></div><div class="ttdeci">auto Run(Func &amp;&amp;f)</div><div class="ttdoc">Execute Callable func on Inline executor.</div><div class="ttdef"><b>Definition</b> <a href="run_8hpp_source.html#l00057">run.hpp:57</a></div></div>
</div><!-- fragment --><p>We guarantee that no more than one allocation will be made for each step of the pipeline.</p>
<p>We have <code>Then/Detach</code> x <code>IExecutor/previous step IExecutor/Inline</code>.</p>
<p>Also Future/Promise don't contain shared atomic counters!</p>
<h3>C++20 coroutine</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1Future.html">yaclib::Future&lt;int&gt;</a> task42() {</div>
<div class="line">  <span class="keyword">co_return</span> 42;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1Future.html">yaclib::Future&lt;int&gt;</a> task43() {</div>
<div class="line">  <span class="keyword">auto</span> value = <span class="keyword">co_await</span> task42();</div>
<div class="line">  <span class="keyword">co_return</span> value + 1;</div>
<div class="line">}</div>
<div class="ttc" id="aclassyaclib_1_1Future_html"><div class="ttname"><a href="classyaclib_1_1Future.html">yaclib::Future</a></div><div class="ttdoc">Provides a mechanism to access the result of async operations.</div><div class="ttdef"><b>Definition</b> <a href="async_2future_8hpp_source.html#l00211">future.hpp:211</a></div></div>
</div><!-- fragment --><p>You can zero cost-combine Future coroutine code with Future callbacks code. That allows using YAClib for a smooth transfer from C++17 to C++20 with coroutines.</p>
<p>Also Future with coroutine doesn't make additional allocation for Future, only coroutine frame allocation that is caused by compiler, and <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0981r0.html">can be optimized</a>.</p>
<p>And finally <code>co_await</code> doesn't require allocation, so you can combine some async operation without allocation.</p>
<h3>Lazy pipeline</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> task = <a class="code hl_function" href="namespaceyaclib.html#a89c63fc03e7f73d8981b57b912e85e7d">yaclib::Schedule</a>(tp1, [] {</div>
<div class="line">  <span class="keywordflow">return</span> 1; </div>
<div class="line">}).Then([] (<span class="keywordtype">int</span> x) {</div>
<div class="line">  <span class="keywordflow">return</span> x * 2;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">task.Run(); <span class="comment">// Run task on tp1</span></div>
<div class="ttc" id="anamespaceyaclib_html_a89c63fc03e7f73d8981b57b912e85e7d"><div class="ttname"><a href="namespaceyaclib.html#a89c63fc03e7f73d8981b57b912e85e7d">yaclib::Schedule</a></div><div class="ttdeci">auto Schedule(Func &amp;&amp;f)</div><div class="ttdoc">Execute Callable func on Inline executor.</div><div class="ttdef"><b>Definition</b> <a href="schedule_8hpp_source.html#l00033">schedule.hpp:33</a></div></div>
</div><!-- fragment --><p>Same as asynchronous pipeline, but starting only after Run/ToFuture/Get. Task can be used as coroutine return type too.</p>
<p>Also running a Task that returns a Future doesn't make allocation. And it doesn't need synchronization, so it is even faster than asynchronous pipeline.</p>
<h3>Thread pool</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> tp{<span class="comment">/*threads=*/</span>4};</div>
<div class="line">Submit(tp, [] {</div>
<div class="line">  <span class="comment">// some computations...</span></div>
<div class="line">});</div>
<div class="line"><a class="code hl_function" href="namespaceyaclib.html#a1c0acaa9b89820432d210ddcc71cb42e">Submit</a>(tp, [] {</div>
<div class="line">  <span class="comment">// some computations...</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">tp.Stop();</div>
<div class="line">tp.Wait();</div>
<div class="ttc" id="anamespaceyaclib_html_a1c0acaa9b89820432d210ddcc71cb42e"><div class="ttname"><a href="namespaceyaclib.html#a1c0acaa9b89820432d210ddcc71cb42e">yaclib::Submit</a></div><div class="ttdeci">void Submit(IExecutor &amp;executor, Func &amp;&amp;f)</div><div class="ttdoc">Submit given func for details.</div><div class="ttdef"><b>Definition</b> <a href="submit_8hpp_source.html#l00017">submit.hpp:17</a></div></div>
</div><!-- fragment --><h3>Strand, Serial executor</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> cpu_tp{4};  <span class="comment">// thread pool for cpu tasks</span></div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> io_tp{1};   <span class="comment">// thread pool for io tasks</span></div>
<div class="line"><span class="keyword">auto</span> strand = <a class="code hl_function" href="namespaceyaclib.html#a7f7d050cd191bf12f4b29b3f97050c83">yaclib::MakeStrand</a>(&amp;tp);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 100; ++i) {</div>
<div class="line">  <a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(cpu_tp, [] {</div>
<div class="line">    <span class="comment">// ... parallel computations ...</span></div>
<div class="line">  }).Then(strand, [](<span class="keyword">auto</span> result) {</div>
<div class="line">    <span class="comment">// ... critical section ...</span></div>
<div class="line">  }).Then(io_tp, [] {</div>
<div class="line">    <span class="comment">// ... io tasks ...</span></div>
<div class="line">  }).<a class="code hl_enumvalue" href="namespaceyaclib_1_1detail.html#a8d958ef9a3a9b6191c21e88df65cec2baf200763a0dca7d4843032c057804f9e9">Detach</a>();</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceyaclib_html_a7f7d050cd191bf12f4b29b3f97050c83"><div class="ttname"><a href="namespaceyaclib.html#a7f7d050cd191bf12f4b29b3f97050c83">yaclib::MakeStrand</a></div><div class="ttdeci">IExecutorPtr MakeStrand(IExecutorPtr e)</div><div class="ttdoc">Strand is the asynchronous analogue of a mutex.</div><div class="ttdef"><b>Definition</b> <a href="src_2exe_2strand_8cpp_source.html#l00071">strand.cpp:71</a></div></div>
</div><!-- fragment --><p>This is much more efficient than a mutex because</p><ol type="1">
<li>don't block the threadpool thread.</li>
</ol>
<ol type="1">
<li>we execute critical sections in batches (the idea is known as flat-combining).</li>
</ol>
<p>And also the implementation of strand is lock-free and efficient, without additional allocations.</p>
<h3>Mutex</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> cpu_tp{4};  <span class="comment">// thread pool for cpu tasks</span></div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> io_tp{1};   <span class="comment">// thread pool for io tasks</span></div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1Mutex.html">yaclib::Mutex&lt;&gt;</a> m;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> compute = [&amp;] () -&gt; <a class="code hl_class" href="classyaclib_1_1Future.html">yaclib::Future&lt;&gt;</a> {</div>
<div class="line">  <span class="keyword">co_await</span> <a class="code hl_function" href="namespaceyaclib.html#a56dc2c5b95bbc3b8cd706654e0c49ba9">On</a>(tp);</div>
<div class="line">  <span class="comment">// ... parallel computations ...</span></div>
<div class="line">  <span class="keyword">auto</span> guard = <span class="keyword">co_await</span> m.<a class="code hl_function" href="classyaclib_1_1Mutex.html#a66044ec2c4a1bd8e214b810010a5cfd0">Lock</a>();</div>
<div class="line">  <span class="comment">// ... critical section ...</span></div>
<div class="line">  <span class="keyword">co_await</span> guard.UnlockOn(io_tp);</div>
<div class="line">  <span class="comment">// ... io tasks ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 100; ++i) {</div>
<div class="line">  compute().Detach();</div>
<div class="line">}</div>
<div class="ttc" id="aclassyaclib_1_1Mutex_html"><div class="ttname"><a href="classyaclib_1_1Mutex.html">yaclib::Mutex</a></div><div class="ttdoc">Mutex for coroutines.</div><div class="ttdef"><b>Definition</b> <a href="coro_2mutex_8hpp_source.html#l00196">mutex.hpp:196</a></div></div>
<div class="ttc" id="aclassyaclib_1_1Mutex_html_a66044ec2c4a1bd8e214b810010a5cfd0"><div class="ttname"><a href="classyaclib_1_1Mutex.html#a66044ec2c4a1bd8e214b810010a5cfd0">yaclib::Mutex::Lock</a></div><div class="ttdeci">auto Lock() noexcept</div><div class="ttdoc">Lock mutex.</div><div class="ttdef"><b>Definition</b> <a href="coro_2mutex_8hpp_source.html#l00237">mutex.hpp:237</a></div></div>
<div class="ttc" id="anamespaceyaclib_html_a56dc2c5b95bbc3b8cd706654e0c49ba9"><div class="ttname"><a href="namespaceyaclib.html#a56dc2c5b95bbc3b8cd706654e0c49ba9">yaclib::On</a></div><div class="ttdeci">YACLIB_INLINE detail::OnAwaiter On(IExecutor &amp;e) noexcept</div><div class="ttdoc">TODO(mkornaukhov03) Add doxygen docs.</div><div class="ttdef"><b>Definition</b> <a href="on_8hpp_source.html#l00011">on.hpp:11</a></div></div>
</div><!-- fragment --><p>First, this is the only correct mutex implementation for C++20 coroutines as far as I know (cppcoro, libunifex, folly::coro implement Unlock incorrectly, it serializes the code after Unlock)</p>
<p>Second, <code>Mutex</code> inherits all the <code>Strand</code> benefits.</p>
<h3>Rescheduling</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1Future.html">yaclib::Future&lt;&gt;</a> bar(<a class="code hl_class" href="classyaclib_1_1IExecutor.html">yaclib::IExecutor</a>&amp; cpu, <a class="code hl_class" href="classyaclib_1_1IExecutor.html">yaclib::IExecutor</a>&amp; io) {</div>
<div class="line">  <span class="keyword">co_await</span> On(cpu);</div>
<div class="line">  <span class="comment">// ... some heavy computation ...</span></div>
<div class="line">  <span class="keyword">co_await</span> On(io);</div>
<div class="line">  <span class="comment">// ... some io computation ...</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassyaclib_1_1IExecutor_html"><div class="ttname"><a href="classyaclib_1_1IExecutor.html">yaclib::IExecutor</a></div><div class="ttdef"><b>Definition</b> <a href="executor_8hpp_source.html#l00008">executor.hpp:8</a></div></div>
</div><!-- fragment --><p>This is really zero-cost, just suspend the coroutine and submit its resume to another executor, without synchronization inside the coroutine and allocations anywhere.</p>
<h3>WhenAll</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> tp{<span class="comment">/*threads=*/</span>4};</div>
<div class="line">std::vector&lt;yaclib::Future&lt;int&gt;&gt; fs;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run parallel computations</span></div>
<div class="line"><span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 5; ++i) {</div>
<div class="line">  fs.push_back(<a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(tp, [i]() -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">    <span class="keywordflow">return</span> random() * i;</div>
<div class="line">  }));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Will be ready when all futures are ready</span></div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1Future.html">yaclib::Future&lt;std::vector&lt;int&gt;</a>&gt; all = <a class="code hl_function" href="namespaceyaclib.html#a8736fbc9ed63e4a569bfebcba66b525c">WhenAll</a>(fs.begin(), fs.size());</div>
<div class="line">std::vector&lt;int&gt; unique_ints = std::move(all).Then([](std::vector&lt;int&gt; ints) {</div>
<div class="line">  ints.erase(std::unique(ints.begin(), ints.end()), ints.end());</div>
<div class="line">  <span class="keywordflow">return</span> ints;</div>
<div class="line">}).Get().Ok();</div>
<div class="ttc" id="anamespaceyaclib_html_a8736fbc9ed63e4a569bfebcba66b525c"><div class="ttname"><a href="namespaceyaclib.html#a8736fbc9ed63e4a569bfebcba66b525c">yaclib::WhenAll</a></div><div class="ttdeci">YACLIB_INLINE auto WhenAll(Futures... futures)</div><div class="ttdef"><b>Definition</b> <a href="when__all_8hpp_source.html#l00020">when_all.hpp:20</a></div></div>
</div><!-- fragment --><p>Doesn't make more than 3 allocations regardless of input size.</p>
<h3>WhenAny</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> tp{<span class="comment">/*threads=*/</span>4};</div>
<div class="line">std::vector&lt;yaclib::Future&lt;int&gt;&gt; fs;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run parallel computations</span></div>
<div class="line"><span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 5; ++i) {</div>
<div class="line">  fs.push_back(<a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(tp, [i] {</div>
<div class="line">    <span class="comment">// connect with one of the database shards</span></div>
<div class="line">    <span class="keywordflow">return</span> i;</div>
<div class="line">  }));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Will be ready when any future is ready</span></div>
<div class="line"><a class="code hl_function" href="namespaceyaclib.html#afe531521c8a34461fd3ccc2ad3fcdc27">WhenAny</a>(fs.begin(), fs.size()).Detach([](<span class="keywordtype">int</span> i) {</div>
<div class="line">  <span class="comment">// some work with database</span></div>
<div class="line">});</div>
<div class="ttc" id="anamespaceyaclib_html_afe531521c8a34461fd3ccc2ad3fcdc27"><div class="ttname"><a href="namespaceyaclib.html#afe531521c8a34461fd3ccc2ad3fcdc27">yaclib::WhenAny</a></div><div class="ttdeci">YACLIB_INLINE auto WhenAny(Futures... futures)</div><div class="ttdef"><b>Definition</b> <a href="when__any_8hpp_source.html#l00013">when_any.hpp:13</a></div></div>
</div><!-- fragment --><p>Doesn't make more than 2 allocations regardless of input size.</p>
<h3>Future unwrapping</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> tp_output{<span class="comment">/*threads=*/</span>1};</div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> tp_compute{<span class="comment">/*threads=CPU cores*/</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> future = <a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(tp_output, [] {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Outer task&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(tp_compute, [] { <span class="keywordflow">return</span> 42; });</div>
<div class="line">}).Then(<span class="comment">/*tp_compute*/</span> [](<span class="keywordtype">int</span> result) {</div>
<div class="line">  result *= 13;</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(tp_output, [result] { </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Result = &quot;</span> &lt;&lt; result &lt;&lt; std::endl; </div>
<div class="line">  });</div>
<div class="line">});</div>
</div><!-- fragment --><p>Sometimes it's necessary to return from one async function the result of the other. It would be possible with the wait on this result. But this would cause blocking of the thread while waiting for the task to complete.</p>
<p>This problem can be solved using future unwrapping: when an async function returns a Future object, instead of setting its result to the Future object, the inner Future will "replace" the outer Future. This means that the outer Future will complete when the inner Future finishes and will acquire the result of the inner Future.</p>
<p>It also doesn't require additional allocations.</p>
<h3>Timed wait</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> tp{<span class="comment">/*threads=*/</span>4};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1Future.html">yaclib::Future&lt;int&gt;</a> f1 = <a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(tp, [] { <span class="keywordflow">return</span> 42; });</div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1Future.html">yaclib::Future&lt;double&gt;</a> f2 = <a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(tp, [] { <span class="keywordflow">return</span> 15.0; });</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespaceyaclib.html#a55739cfc29f728d2620e670c31c70425">WaitFor</a>(10ms, f1, f2);  <span class="comment">// or Wait / WaitUntil</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (f1.<a class="code hl_function" href="classyaclib_1_1FutureBase.html#afc3b6a42975ba1247fe53d3ace812137">Ready</a>()) {</div>
<div class="line">  Process(std::as_const(f1).Get());</div>
<div class="line">  <a class="code hl_class" href="classyaclib_1_1Result.html">yaclib::Result&lt;int&gt;</a> res1 = std::as_const(f1).Get();</div>
<div class="line">  assert(f1.<a class="code hl_function" href="classyaclib_1_1FutureBase.html#a5ee96890a14dd007f7da1db7c3eccf31">Valid</a>());  <span class="comment">// f1 valid here</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (f2.Ready()) {</div>
<div class="line">  Process(std::move(f2).Get());</div>
<div class="line">  assert(!f2.Valid());  <span class="comment">// f2 invalid here</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassyaclib_1_1FutureBase_html_a5ee96890a14dd007f7da1db7c3eccf31"><div class="ttname"><a href="classyaclib_1_1FutureBase.html#a5ee96890a14dd007f7da1db7c3eccf31">yaclib::FutureBase::Valid</a></div><div class="ttdeci">bool Valid() const &amp;noexcept</div><div class="ttdoc">Check if this Future has Promise.</div><div class="ttdef"><b>Definition</b> <a href="async_2future_8hpp_source.html#l00055">future.hpp:55</a></div></div>
<div class="ttc" id="aclassyaclib_1_1FutureBase_html_afc3b6a42975ba1247fe53d3ace812137"><div class="ttname"><a href="classyaclib_1_1FutureBase.html#afc3b6a42975ba1247fe53d3ace812137">yaclib::FutureBase::Ready</a></div><div class="ttdeci">bool Ready() const &amp;noexcept</div><div class="ttdoc">Check that Result that corresponds to this Future is computed.</div><div class="ttdef"><b>Definition</b> <a href="async_2future_8hpp_source.html#l00064">future.hpp:64</a></div></div>
<div class="ttc" id="aclassyaclib_1_1Result_html"><div class="ttname"><a href="classyaclib_1_1Result.html">yaclib::Result</a></div><div class="ttdoc">Encapsulated return value from caller.</div><div class="ttdef"><b>Definition</b> <a href="result_8hpp_source.html#l00090">result.hpp:90</a></div></div>
<div class="ttc" id="anamespaceyaclib_html_a55739cfc29f728d2620e670c31c70425"><div class="ttname"><a href="namespaceyaclib.html#a55739cfc29f728d2620e670c31c70425">yaclib::WaitFor</a></div><div class="ttdeci">YACLIB_INLINE std::enable_if_t&lt;(... &amp;&amp;is_waitable_with_timeout_v&lt; Waited &gt;), bool &gt; WaitFor(const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout_duration, Waited &amp;... fs) noexcept</div><div class="ttdoc">Wait until the specified timeout duration has elapsed or Ready becomes true.</div><div class="ttdef"><b>Definition</b> <a href="wait__for_8hpp_source.html#l00023">wait_for.hpp:23</a></div></div>
</div><!-- fragment --><p>We support <code>Wait/WaitFor/WaitUntil</code>. Also all of them don't make allocation, and we have optimized the path for single <code>Future</code> (used in <code>Future::Get()</code>).</p>
<h3>WaitGroup</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1WaitGroup.html">yaclib::WaitGroup</a> wg{1};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> tp;</div>
<div class="line"> </div>
<div class="line">wg.Add(2<span class="comment">/*default=1*/</span>);</div>
<div class="line">Submit(tp, [] {</div>
<div class="line">   wg.Done();</div>
<div class="line">});</div>
<div class="line"><a class="code hl_function" href="namespaceyaclib.html#a1c0acaa9b89820432d210ddcc71cb42e">Submit</a>(tp, [] {</div>
<div class="line">   wg.Done();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1Future.html">yaclib::Future&lt;int&gt;</a> f1 = <a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(tp, [] {...});</div>
<div class="line">wg.Attach(f1);  <span class="comment">// auto Done then Future became Ready</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classyaclib_1_1Future.html">yaclib::Future&lt;&gt;</a> f2 = <a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(tp, [] {...});</div>
<div class="line">wg.Consume(std::move(f2));  <span class="comment">// auto Done then Future became Ready</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> coro = [&amp;] () -&gt; <a class="code hl_class" href="classyaclib_1_1Future.html">yaclib::Future&lt;&gt;</a> {</div>
<div class="line">  <span class="keyword">co_await</span> <a class="code hl_function" href="namespaceyaclib.html#a56dc2c5b95bbc3b8cd706654e0c49ba9">On</a>(tp);</div>
<div class="line">  <span class="keyword">co_await</span> wg; <span class="comment">// alias for co_await wg.Await(CurrentThreadPool());</span></div>
<div class="line">  std::cout &lt;&lt; f1.Touch().Ok(); <span class="comment">// Valid access to Result of Ready Future</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> coro_f = coro();</div>
<div class="line"> </div>
<div class="line">wg.Done(<span class="comment">/*default=1*/</span>);</div>
<div class="line">wg.Wait();</div>
<div class="ttc" id="aclassyaclib_1_1WaitGroup_html"><div class="ttname"><a href="classyaclib_1_1WaitGroup.html">yaclib::WaitGroup</a></div><div class="ttdoc">An object that allows you to Add some amount of async operations and then Wait for it to be Done.</div><div class="ttdef"><b>Definition</b> <a href="wait__group_8hpp_source.html#l00018">wait_group.hpp:18</a></div></div>
</div><!-- fragment --><p>Effective like simple atomic counter in intrusive pointer, also doesn't require any allocation.</p>
<h3><a class="el" href="classException.html" title=", invalid state">Exception</a> recovering</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> tp{<span class="comment">/*threads=*/</span>4};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> f = <a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(tp, [] {</div>
<div class="line">  <span class="keywordflow">if</span> (random() % 2) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error{<span class="stringliteral">&quot;1&quot;</span>};</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 42;</div>
<div class="line">}).Then([](<span class="keywordtype">int</span> y) {</div>
<div class="line">  <span class="keywordflow">if</span> (random() % 2) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error{<span class="stringliteral">&quot;2&quot;</span>};</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> y + 15;</div>
<div class="line">}).Then([](<span class="keywordtype">int</span> z) {  <span class="comment">// Will not run if we have any error</span></div>
<div class="line">  <span class="keywordflow">return</span> z * 2;</div>
<div class="line">}).Then([](std::exception_ptr e) {  <span class="comment">// Recover from error codes</span></div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    std::rethrow_exception(e);</div>
<div class="line">  } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; e) {</div>
<div class="line">    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 10;  <span class="comment">// Some default value</span></div>
<div class="line">});</div>
<div class="line"><span class="keywordtype">int</span> x = std::move(f).Get().Value();</div>
</div><!-- fragment --><h3>Error recovering</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> tp{<span class="comment">/*threads=*/</span>4};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> f = <a class="code hl_function" href="namespaceyaclib.html#ac918e7a0c384bcf611e0b5b4b2cd5504">yaclib::Run&lt;std::error_code&gt;</a>(tp, [] {</div>
<div class="line">  <span class="keywordflow">if</span> (random() % 2) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_error_code(1);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 42;</div>
<div class="line">}).Then([](<span class="keywordtype">int</span> y) {</div>
<div class="line">  <span class="keywordflow">if</span> (random() % 2) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_error_code(2);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> y + 15;</div>
<div class="line">}).Then([](<span class="keywordtype">int</span> z) {  <span class="comment">// Will not run if we have any error</span></div>
<div class="line">  <span class="keywordflow">return</span> z * 2;</div>
<div class="line">}).Then([](std::error_code ec) {  <span class="comment">// Recover from error codes</span></div>
<div class="line">  std::cout &lt;&lt; ec.value() &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 10;  <span class="comment">// Some default value</span></div>
<div class="line">});</div>
<div class="line"><span class="keywordtype">int</span> x = std::move(f).Get().Value();</div>
<div class="ttc" id="anamespaceyaclib_html_ac918e7a0c384bcf611e0b5b4b2cd5504"><div class="ttname"><a href="namespaceyaclib.html#ac918e7a0c384bcf611e0b5b4b2cd5504">yaclib::MakeContract</a></div><div class="ttdeci">Contract&lt; V, E &gt; MakeContract()</div><div class="ttdoc">Creates related future and promise.</div><div class="ttdef"><b>Definition</b> <a href="contract_8hpp_source.html#l00025">contract.hpp:25</a></div></div>
</div><!-- fragment --><h3>Use Result for smart recovering</h3>
<div class="fragment"><div class="line"><a class="code hl_class" href="classyaclib_1_1FairThreadPool.html">yaclib::FairThreadPool</a> tp{<span class="comment">/*threads=*/</span>4};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> f = <a class="code hl_function" href="namespaceyaclib.html#a7a1e816f25355b1f23b01433879ed0ec">yaclib::Run</a>(tp, [] {</div>
<div class="line">  <span class="keywordflow">if</span> (random() % 2) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_error_code(1);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 42;</div>
<div class="line">}).Then([](<span class="keywordtype">int</span> y) {</div>
<div class="line">  <span class="keywordflow">if</span> (random() % 2) {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error{<span class="stringliteral">&quot;2&quot;</span>};</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> y + 15;</div>
<div class="line">}).Then([](<a class="code hl_class" href="classyaclib_1_1Result.html">yaclib::Result&lt;int&gt;</a>&amp;&amp; z) {</div>
<div class="line">  <span class="keywordflow">if</span> (!z) {</div>
<div class="line">    <span class="keywordflow">return</span> 10;  <span class="comment">// Some default value</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> std::move(z).Value();</div>
<div class="line">});</div>
<div class="line"><span class="keywordtype">int</span> x = std::move(f).Get().Value();</div>
</div><!-- fragment --><h1>Requirements</h1>
<p>YACLib is a static library, that uses <em>CMake</em> as a build system and requires a compiler with C++17 or newer.</p>
<p>If the library doesn't compile on some compiler satisfying this condition, please create an issue. Pull requests with fixes are welcome!</p>
<p>We can also try to support older standards. If you are interested in it, check this <a href="https://github.com/YACLib/YACLib/discussions/102">discussion</a>.</p>
<p>We test following configurations:</p>
<p>✅ - CI tested</p>
<p>👌 - manually tested</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Compiler\OS   </th><th class="markdownTableHeadNone">Linux   </th><th class="markdownTableHeadNone">Windows   </th><th class="markdownTableHeadNone">macOS   </th><th class="markdownTableHeadNone">Android    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GCC   </td><td class="markdownTableBodyNone">✅ 7+   </td><td class="markdownTableBodyNone">👌 MinGW   </td><td class="markdownTableBodyNone">✅ 7+   </td><td class="markdownTableBodyNone">👌    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Clang   </td><td class="markdownTableBodyNone">✅ 8+   </td><td class="markdownTableBodyNone">✅ ClangCL   </td><td class="markdownTableBodyNone">✅ 8+   </td><td class="markdownTableBodyNone">👌    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AppleClang   </td><td class="markdownTableBodyNone">—   </td><td class="markdownTableBodyNone">—   </td><td class="markdownTableBodyNone">✅ 12+   </td><td class="markdownTableBodyNone">—    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MSVC   </td><td class="markdownTableBodyNone">—   </td><td class="markdownTableBodyNone">✅ 14.20+   </td><td class="markdownTableBodyNone">—   </td><td class="markdownTableBodyNone">—   </td></tr>
</table>
<p>MinGW works in CI early, check <a href="https://github.com/YACLib/YACLib/issues/190">this</a>.</p>
<h1>Releases</h1>
<p>YACLib follows the <a href="https://abseil.io/about/philosophy#upgrade-support">Abseil Live at Head philosophy</a> (update to the latest commit from the main branch as often as possible).</p>
<p>So we recommend using the latest commit in the main branch in your projects.</p>
<p>This is safe because we suggest compiling YACLib from source, and each commit in main goes through dozens of test runs in various configurations. Our test coverage is 100%, to simplify, we run tests on the cartesian product of possible configurations:</p>
<p><code>os x compiler x stdlib x sanitizer x fault injection backend</code></p>
<p>However, we realize this philosophy doesn't work for every project, so we also provide <a href="https://github.com/YACLib/YACLib/releases">Releases</a>.</p>
<p>We don't believe in <a href="https://semver.org">SemVer</a> (check <a href="https://gist.github.com/jashkenas/cbd2b088e20279ae2c8e">this</a>), but we use a <code>year.month.day[.patch]</code> versioning approach. I'll release a new version if you ask, or I'll decide we have important or enough changes.</p>
<h1>Contributing</h1>
<p>We are always open for issues and pull requests. Check our <a href="https://github.com/YACLib/YACLib/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">good first issues</a>.</p>
<p>For more details you can check the following links:</p>
<ul>
<li><a href="https://yaclib.github.io/YACLib">Specification</a></li>
<li><a class="el" href="md_doc_2target.html">Targets description</a></li>
<li><a class="el" href="md_doc_2dependency.html">Dev dependencies</a></li>
<li><a class="el" href="md_doc_2style__guide.html">Style guide</a></li>
<li><a class="el" href="md_doc_2sanitizer.html">How to use sanitizers</a></li>
</ul>
<h1>Thanks</h1>
<ul>
<li><a href="https://gitlab.com/Lipovsky">Roman Lipovsky</a> for an incredible <a href="https://gitlab.com/Lipovsky/concurrency-course">course about concurrency</a>, which gave us a lot of ideas for this library and for showing us how important to test concurrency correctly.</li>
<li>Paul E. McKenney for an incredible <a href="https://cdn.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html">book about parallel programming</a>, which gave me a lot of insight into memory models and how they relate to what's going on in hardware.</li>
</ul>
<h1>Contacts</h1>
<p>You can contact us by my email: <a href="#" onclick="location.href='mai'+'lto:'+'val'+'er'+'y.m'+'ir'+'ono'+'w@'+'gma'+'il'+'.co'+'m'; return false;">valer<span class="obfuscator">.nosp@m.</span>y.mi<span class="obfuscator">.nosp@m.</span>ronow<span class="obfuscator">.nosp@m.</span>@gma<span class="obfuscator">.nosp@m.</span>il.co<span class="obfuscator">.nosp@m.</span>m</a></p>
<p>Or join our <a href="https://discord.gg/xy2fDKj8VZ">Discord Server</a></p>
<h1>License</h1>
<p>YACLib is made available under MIT License. See [LICENSE](LICENSE) file for details.</p>
<p>We would be glad if you let us know that you're using our library.</p>
<p><a href="https://app.fossa.com/projects/git%2Bgithub.com%2FYACLib%2FYACLib?ref=badge_large"><img src="https://app.fossa.com/api/projects/git%2Bgithub.com%2FYACLib%2FYACLib.svg?type=large" alt="FOSSA Status" style="pointer-events: none;" class="inline"/></a> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
